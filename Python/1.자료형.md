# 자료형
## 수 자료형
### 정수형

```py
a = 10      // 양의 정수   
print(a)    // 10   

a = -10     // 음의 정수   
print(a)    // -10   

a = 0    
print(a)    // 0   
```


### 실수형
```py
a = 123.45   
print(a)    // 123.45   

a = -123.45   
print(a)    // -123.45

a = 1.   
print(a)    // 1.0   

a = -.1   
print(a)    // -0.1   
```

e, E를 사용하여 지수 표현 방식을 이용할 수 있다.   
e 다음에 오는 수는 10의 지수부를 의미한다.   

**1e4 = 10의 4제곱**    
최단 경로 문제에서는 도달할 수 없는 노드에 대하여 최단 거리를 무한(1NF)로 설정한다.   
최단 경로로 가능한 최댓값이 10억 미만이라면 무한(1NF)을 표현할 때, 10억을 이용할 수 있다.   
이때 10억을 변수에 대입하것보다는 1e9로 표현할 수 있다.   

```py
a = 1e9  // 10억

a = 12.34e1  // 123.4

a = 1234e-3 // 1.234
```

**컴퓨터는 실수를 정확히 표현하지 못한다.**

```py
a = 0.3 + 0.6  // 0.89999999999999
```

따라서 소수점 값을 비교하는 작업이 필요한 문제는 round() 함수를 이용한다.    
**round('실수형 데이터', '반올림하고자 하는 위치 -1');  // 두번째 인자가 없을땐 소수점 첫째 자리에서 반올림**
```py
round(123,456, 2)   // 소수 셋제짜리에서 반올림. 123.46
```

**보통 실수형 데이터를 비교할 때 소수점 다섯째 자리에서 반올림한 결과가 같으면 정답으로 인정한다.**

```py
a = 0.3 + 0.6
round(a, 4) == 0.9  // True
```


### 수 자료형의 연산
파이썬에서 나누기 연산자(/)는 나눠진 결과를 기본적으로 실수형으로 처리한다.   
나눈 결과에서 몫만을 얻고자 할 때는 몫 연산자(//)를 이용한다.    
```py
a = 7
b = 3

print(a/b)   // 2.333333333335

print(a%b)   // 1

print(a//b)  // 2

print(a**b)  // 7의 3 거듭제곱
```


## 리스트 자료형
파이썬의 리스트 자료형은 배열의 기능과 연결 리스트 자료구조를 채택하고 있어서 append(), remove() 등의 메서드를 지원한다.   

### 리스트 만들기
```py
a = [1, 2, 3, 4, 5]
print(a)  //  [1, 2, 3, 4, 5]

print(a[4])  //  5

// 빈 리스트 선언법
a = list()  // []
a = []      // []
```

**크기가 N인 1차원 리스트를 초기화하는 방법**    
```py
n = 5
a = [0] * n  //  [0, 0, 0, 0, 0]
```


### 리스트의 인덱싱과 슬라이싱

#### 인덱싱
인덱스값을 입력하여 리스트의 특정한 원소에 접근하는 것을 인덱싱 이라고 한다.   
파이썬의 인덱스값은 양의 정수와 음의 정수 모두 사용할 수 있으며, 음의 정수를 넣으면 원소를 거꾸로 탐색한다.   
ex) 인덱스에 -1을 넣으면 가장 마지막 원소가 출력된다.   

```py
a = [1, 2, 3, 4, 5]

print(a[-1])  //  5

print(a[-3]   //  3

a[3] = 0
print(a)      //  [1, 2, 0, 4, 5]
```

#### 슬라이싱
리스트에서 연속적인 위치를 갖는 원소들을 가져와야 할 때는 슬라이싱을 이용한다.   
이때는 대괄호 안에 콜론(:)을 넣어서 시작 인덱스, 끝 인덱스(-1)을 설정할 수 있다.   
(끝의 인덱스의 경우 1을 뺀 값의 인덱스까지 처리된다.)   
```py
a = [1, 2, 3, 4, 5]

print( a[1 : 4] )  //  [2, 3, 4]
```

### 리스트 컴프리헨션
리스트 컴프리헨션은 리스트를 초기화하는 방법 중 하나이다.   
리스트 컴프리헨션을 이용하면 대괄호([]) 안에 조건문과 반복문을 넣는 방식으로 리스트를 초기화한다.  
0부터 9까지의 숫자중에서 짝수만 포함하는 리스트를 만들때는 다음과 같이 리스트를 초기화할 수 있다.    
```py
arr = [i for i in range(10) if i % 2 == 0]

print(arr)  //  [2, 4, 6, 8]
```

1부터 9까지의 수의 제곱 값을 포함하는 리스트
```py
arr = [i * i for i in range(1, 5)]
print(arr)  //  [1, 4, 9, 16]
```

**리스트 컴프리헨션은 2차원 리스트를 초기화할 때 매우 효과적이다.**   
N X M 크기의 2차원 리스트를 초기화할 때는 다음과 같다.   
```py
n = 3
m = 4
arr = [[0] * m for _ in range(n)]
print(arr)    //    [[0,0,0,0], [0,0,0,0], [0,0,0,0]]
```

**언더바(_)의 역할**
파이썬에서 반복을 수행하되 반복을 위한 변수의 값을 무시하고자 할 때 언더바(_)를 자주 사용한다.   
1부터 9까지의 자연수를 더할때는
```py 
sum =0
for i in range(1, 10):
    sum += i
print(sum)
```
이렇게 하지만   

단순히 문자열을 반복해서 출력할 때는
```py 
for _ in range(5):
    print("hello")
``` 
언더바(_)를 이용하여 무시할 수 있다.

2차원 리스트 초기화는 무조건 리스트 컴프리헨션을 이용해야 한다.   
다음은 잘못된 초기화 방법이다.   
```py
n = 3
m = 4
arr = [[0] * m] * n  //   [[0,0,0,0], [0,0,0,0], [0,0,0,0]]

arr[1][1] = 5  //   [[0,5,0,0], [0,5,0,0], [0,5,0,0]]
```
내부적으로 포함된 3개의 리스트가 모두 동일한 객체에 대한 3개의 레퍼런스로 인식되기 때문이 이런 결과가 나온다.   

### 리스트 관련 기타 메소드

```py
a = [1, 2, 3]

a.append(4)   // [1, 2, 3, 4]

a.sort()      // [1, 2, 3, 4]

a.sort(reverse = True)      // [4, 3, 2, 1]

a.reverse()                 // [1, 2, 3, 4]

a.insert(2, 5)              // 인덱스 2에 5 추가 [1, 2, 5, 3, 4]

a.count(1)                  // 값 1의 갯수 세기. 1

a.remove(5)                 // 값 5 제거 [1, 2, 3, 4]
``` 

**리스트에 특정한 값의 원소를 모두 제거하는 방법**
```py
a = [1, 2, 3, 4, 5]
remove_set = [3, 5]

# remove_set에 포함되지 않은 값만 result에 저장
result = [i for i in a if i not in remove_set]
print(result)  // [1, 2, 4]
```



## 문자열 자료형
### 문자열 초기화
```py
str = 'Hello'               // Hello
str = "Hello \"Gisun\""     // Hello "Gisun"
```

### 문자열 연산
```py
str = "hello"
print(str * 3)  // hellohellohello
```

파이썬의 문자열은 내부적으로 리스트와 같이 처리된다.   
문자열은 여러개의 문자가 합쳐진 리스트라고 볼 수 있다.   
따라서 문자열에도 인덱싱과 슬라이싱을 할 수 있다.
```py
a = "ABCDE"
print(a[2 : 4])  // CD
```

## 튜플 자료형
파이썬의 튜플 자료형은 리스트와 거의 비슷한다 다음과 같은 차이가 있다.
* 튜플은 한 번 선언된 값을 변경할 수 없다.
* 리스트는 대괄호([])를 이용하지만, 튜플은 소괄호(())를 이용한다.

```py
a = (1, 2, 3, 4)
print(a)         // (1, 2, 3, 4)
```

튜플 자료형은 그래프 알고리즘을 구현할 때 자주 사용된다.   
예를들어 다익스트라 최단 경로 알고리즘처럼 최단 경로를 찾아주는 알고리즘의 내부에서는 우선순위 큐를 이용하는데 해당 알고리즘에서 우선순위 큐에 한번 들어간 값은
 변경되지 않는다. 그래서 그 우선순위 큐에 들어가는 데이터를 튜플로 구성하여 소스코드를 작성한다.   
튜플을 이용하면 혹여나 변경되면 안되는 값이 변경되고 있는지 확인이 가능하다.   
또 튜플은 리스트에 비해 상대적으로 공간 효율적이고, 일반적으로 각 원소의 성질이 다를때 주로 사용한다.   
흔히 다익스트라 최단 경로 알고리즘에서는 '비용'과 '노드 번호'라는 서로 다른 성질의 데이터를 (비용, 노드 번호)의 형태로 함께 튜플로 묶어서 관리한다.


## 사전 자료형
사전 자료형은 key/value를 가지는 자료형이다. 사전 자료형의 대표적인 예시는 사전이다.
key로 한글, value로 영어 단어를 넣어서 사전을 만들 수 있다. 사전 자료형은 내부적으로 Hash Table을 이용하므로
기본적으로 데이터의 검색 및 수정에 있어서 O(1)의 시간에 처리할 수 있다.   
```py
data = dict()
data['버스'] = 'Bus'
data['택시'] = 'Taxi'

print(data)  //  {'버스': 'Bus', '택시': 'Taxi'}
```
사전 자료형에 특정한 원소가 있는지 검사할 때는 '원소 in 사전'의 형태를 사용할 수 있다.   
이는 리스트나 튜플에서도 사용할 수 있다.   

```py
data = dict()
data['버스'] = 'Bus'
data['택시'] = 'Taxi'

if '버스' in data:
    print("'버스'를 키로 가지는 데이터가 존재합니다.")  // '버스'를 키로 가지는 데이터가 존재합니다."
```



## 집합 자료형
### 소개
집합은 리스트 또는 문자열을 이용해서 만들 수 있는데, 집합은 다음과 같은 특징이 있다.   
```py
* 중복을 허용하지 않는다.
* 순서가 없기에 인덱싱으로 값을 얻을 수 없다.
* 키가 존재하지 않고, 각 데이터만을 담게 된다.
* 특정 원소가 존재하는지를 검사하는 시간 복잡도는 O(1)
```
**집합 자료형은 "특정한 데이터가 이미 등장한 적이 있는지 여부" 를 체크할 때 매우 효과적이다.**   
**집합 자료형 초기화 방법**

```py
data = set([1, 2, 3, 4, 5])
data = {1, 2, 3, 4, 5}
```

### 연산
기본적인 집합 연산은 합집합, 교집합, 차집합 연산이 있다.
```py
data = set([1, 2, 3])
data = set([3, 4, 5])

print(a | b)  // 합집합  {1, 2, 3, 4, 5}
print(a & b)  // 교집합  { 3 }
print(a - b)  // 차집합  {1, 2}
```

### 집합 자료형 관련 함수
```py
data = set([1, 2, 3])

# 원소 한개 추가 O(1)
data.add(4)
print(data)  // {1, 2, 3, 4}

# 원소 여러개 추가
data.update([5, 6])
print(data)  // {1, 2, 3, 4, 5, 6}

# 특정 값 원소 삭제 O(1)
data.remove(3)
print(data)  // {1, 2, 4, 5, 6}
```