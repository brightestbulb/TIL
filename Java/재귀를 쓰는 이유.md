# 재귀 함수를 쓰는 이유
재귀 호출은 Stack 메모리에 함수의 Stack Call이 반복적으로 이루어 지므로 성능이 안좋다고 한다.
그렇다면 왜 재귀 함수를 쓸까.

```html
1. 알고리즘 자체가 재귀적으로 표현하면 가독성이 좋아진다.
2. 변수의 사용을 줄여준다.
```

변수가 사용하는 메모리가 아니라, **mustable state(변경 가능한 상태)** 를 제거하여 프로그램 오류가 발생할 수 있는
가능성을 줄인다는 것이다.   
이는 함수형 프로그래밍에서 함수를 객체로 취급하여 함수를 인자로 전달, 반환하여 mustable state 상태를 제거하는것과 비슷하다.

## 재귀 함수 단점

- 메모리를 많이 차지하며 성능이 반복문에 비해 느리다.
- 함수를 호출 시 함수의 매개변수, 지역변수, 리턴값, 함수 종료 후 돌아갈 위치가 Stack 메모리에 저장된다.
- 재귀 함수를 쓰면 함수를 반복적으로 호출하므로, 스택 메모리가 커지고 호출하는 횟수가 많아지면 Stack Overflow가 발생할 수 있다.
- Stack 프레임을 구성하고 해제하는 과정에서 반복문보다 오버헤드가 들어 성능이 저하된다.


## 꼬리 재귀

- 재귀의 단점을 꼬리 재귀로 해결
- 컴파일러가 꼬리 재귀 최적화를 지원해야 된다.

**재귀**
```java
public int Recursive(int n) {
    if(n==1){ return 1; }
    return n + Recursive(n-1);
}
```
일반 재귀는 return에 연산을 하지만, 꼬리 재귀는 return에 연산을 하지 않는다. 매개 변수로 필요한 연산을 전달한다.

**꼬리 재귀**
```java
public int Tail_Recursive(int n, int acc){
    if(n==1) { return acc };
    return Tail_Recursive(n-1, n + acc );
}
```

컴파일러가 꼬리 재귀를 최적화하는 과정에서 꼬리 재귀를 반복문으로 변경한다.   
그러므로 재귀의 문제점인 메모리와 성능에 대한 문제가 해결된다.   

## 재귀의 예시

**재귀의 안좋은 예**
- 피보나치 수 구하기
- 행렬 곱셈 최적 순서 구하기

**재귀의 좋은 예**
- 퀵 정렬, 병합 정렬 등의 알고리즘
- factorial 계산
- 그래프의 DFS

