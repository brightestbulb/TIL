# 생성자 대신 정적 팩터리 메서드를 사용할 수 없는가.

클래스를 통해서 객체를 만드는 방법으로는 public으로 선언된 생성자를 이용하는 것이지만 반드시 알아야 하는 방법이 하나 더 있는데 클래스에 public 으로 선언된 **정적 팩터리 메소드**를 추가하는 것이다.

```java
public static Boolean valueOf(boolean a){
    return a ? Boolean.TRUE : Boolean.FALSE;
}
```

#### 정적 팩터리 메서드의 장점
1. **생성자와는 달리 정적 팩터리 메서드에는 이름이 있다.**
생성자에 전달되는 인자들은 어떤 객체가 생성되는지 모르지만, 정적 팩터리 메서드는 이름을 잘 짓는다면 코드의 가독성이 높아진다.
예를들어 여러개의 다국어 메세지를 구분자로 구분하는 객체를 생성하는 생성자 **MessageConverter(msg, deli)** 는 **MessageConverter.seperateWithDeli** 과
 같은 이름의 정적 팩터리 메서드로 표현하면 더 이해하기 쉽다.
생성자의 인자를 바꿔가면서 여러개의 생성자를 만드는 방법이 있는데, 이 방법을 쓰다보면 실수가 발생할 수 있다.
이것보단 정적 팩터리 메서드를 사용하여 메서드 이름으로 차이가 명확히 드러나도록 네이밍에 신경을 쓰자.

2. **생성자와 달리 호출할 때마다 새로운 객체를 생성할 필요가 없다.**
만든 객체를 캐시해놓고 재사용하여 같은 객체가 불필요하게 거듭 생성되는 일을 피할 수도 있다. 앞서본 Boolean.valueOf(Boolean) 메서드
는 이 기법을 활용한 좋은 예다. 절대 객체를 생성하지 않는 것이다. 동일한 객체가 요청되는 일이 잦고, 특히 객체를 만드는 비용이 클 때 적용하면
성능을 크게 개선할 수 있다.

3. **생성자와 다르게 반환값 자료형의 하위 자료형 객체를 반환 가능.**
반환되는 객체의 클래스가 public으로 선언되지 않아도 반환하는 API를 만들 수 있다. 그럼 클래스가 캡슐화가 되고 간결한 API가 된다.
정적 팩터리 메서드의 반환값으로 인터페이스를 활용한다. 예를들어 자바의 컬렉션 프레임워크에는 32개의 컬렉션 인터페이스 구현체가 있는데, 이 구현체들은 전부 
java.util.Collecitons라는 객체 생성 불가능 클래스의 정적 팩터리 메서드를 통해 이용하는데, 반환되는 객체의 실제 클래스는 public이 아니다.
구현체별로 public 클래스를 만들었다면 컬렉션 프레임워크 API의 규모는 커졌을 것이다. 인터페이스 기반 기법 덕에 간단해졌다.
API 사용자는 별도의 클래스 사용법 문서를 읽지 않아도 그 구현체를 이용할 수 있다. 또 클라이언트 코드는 반환된 객체의 실제 구현 세부사항이 아니라
인터페이스만 보고 작성하게 되는데 바람직한 습관이다.