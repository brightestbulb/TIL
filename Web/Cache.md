## Web Cache

### 캐싱 기본 개념
캐싱은 애플리케이션의 처리 속도를 높여준다.    
이미 가져온 데이터나 계산된 결과값의 복사본을 저장함으로써 처리 속도를 향상시키며    
이를 통해 향후 요청을 더 빠르게 처리할 수 있다.   
대부분의 프로그램이 동일한 데이터나 명령어에 반복해서 엑세스하기 때문에 캐싱은 효율적인 아키텍처 패턴이다.   

### 웹 캐쉬
사용자(Client)가 웹사이트(Server)에 접속할 때, 정적 컨텐츠(Img, JS, CSS 등)를   
특정 위치(Client, Network) 등에 저장하여 웹사이트 서버에 해당 컨텐츠를 매번 요청하여 받는것이 아니라,   
특정 위치에서 불러옴으로써 응답시간을 줄이고 서버 트래픽 감소 효과를 볼 수 있다.    


### 웹 캐쉬의 종류
이 세가지 종류 중에서 브라우저 캐쉬에 대해서 중점적으로 살펴본다.
1. Browser Caches
- 브라우저 또는 HTTP 요청을 하는 Client Application에 의해 내부 디스크에 캐쉬
- 브라우저의 뒤로가기 버튼 또는 이미 방문한 페이지를 재 방문하는 경우 극대화


2. Proxy Caches
- Browser Cache와 동일한 원리로 동작하며 Client나 Server 가 아닌 네트워크 상에서 동작.
- 큰 회사나 IPS의 방화벽에 설치 되며 대기시간 & 트래픽 감소, 접근정책 & 제한 우회, 사용률 기록 등 수행
- 한정된 수의 클라이언트을 위하여 무한대의 웹서버의 컨텐츠를 캐쉬


3. Gateway Caches (REVERSE OR SURROGATE PROXY)
- 서버 앞 단에 설치되어 요청에 대한 캐쉬 및 효율적인 분배를 통해 가용성, 신뢰성, 성능등을 향상
- Encryption / SSL acceleration, Load balancing, Serve/cache static content, Compression등을 수행
- 무한대의 클라이언트들에게 한정된 수(또는 하나)의 웹서버 컨텐츠를 제공


### 어떻게 캐쉬를 컨트롤 하나?
브라우저는 한번 요청한 파일은 이 후부터는 캐쉬를 사용하는데, 만약 캐쉬를 사용하지 않거나 캐쉬된 내용이 변경되면 어떻게 할까?
브라우저가 어떻게 캐쉬를 컨트롤하는지 알아보자.

#### HTTP Headers를 사용하는 방법
파일을 이전과 비교하여 변경 되었는지를 체크하는 **validation** 과 캐쉬 만료 여부를 체크하는 **freshness** 로 구성된다.   
request와 response에 따라 서로 사용될 수 있는 값이 다르며 HTTP 1.0에서 HTTP 1.1로 넘어오면서 약간의 변화가 있다.   
HTTP 1.1의 Cache-Control은 하나의 값이 아니라 다양한 지시자를 ','를 이용하여 값을 전달한다.   
이로 인해 여러가지 컨트롤을 가능하게 만들어 준다. ex) Cache-Control:max-age=3600, must-revalidate   
( 다양한 지시자는 출처 링크를 타고 가서 확인하자 )   



### 어떻게 캐쉬가 동작할까?
캐쉬가 일어나는 과정에서 HTTP Header들이 어떻게 사용되는지 살펴보자.   


#### 첫 요청
1. 브라우저는 서버에 index.html 파일을 요청한다.
2. 서버는 index.html 파일을 찾아보고 존재하는 파일이라면 파일 내용을 브라우저에게 몇가지 header 값과 함께 응답한다.
3. 브라우저는 응답받은 내용을 브라우저에 표시하고 응답 헤더의 내용에 따라 캐쉬 정책을 수행한다.   
( 응답 헤더에 Last-Modified, Etag, Expires, Cache-Control:max-age 항목이 존재하면 복사본을 생성하고 값 저장 )   




출처 : https://hahahoho5915.tistory.com/33